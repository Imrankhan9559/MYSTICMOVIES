{% extends "base.html" %}
{% block content %}

<div id="publicApp" class="min-h-screen bg-black flex flex-col items-center justify-center p-4" data-token="{{ token }}" data-username="{{ viewer_name }}" data-item-id="{{ item.id }}">
    <div id="viewerGate" class="viewer-gate hidden">
        <div class="viewer-card">
            <div class="viewer-title">Who's watching?</div>
            <div class="viewer-sub">Enter your name to save progress and resume later.</div>
            <input id="viewerInput" type="text" placeholder="Your name" class="viewer-input" />
            <button id="viewerSubmit" class="viewer-btn">Continue</button>
            <div id="viewerHint" class="viewer-hint"></div>
        </div>
    </div>
    
    <div class="w-full max-w-4xl bg-zinc-950 rounded-xl shadow-2xl overflow-hidden border border-zinc-800 relative">
        
        <div class="bg-black p-4 border-b border-zinc-800 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
            <div class="flex items-center text-white">
                <i class="fas {{ item.icon }} text-red-500 text-2xl mr-3"></i>
                <div>
                    <h1 class="font-bold text-lg truncate max-w-full sm:max-w-md">{{ display_title or item.name }}</h1>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 w-full sm:w-auto justify-start sm:justify-end">
                <a href="{{ download_url or stream_url }}" class="px-4 py-2 rounded bg-zinc-900 border border-zinc-700 text-sm text-gray-100 hover:border-yellow-500 font-bold transition w-full sm:w-auto text-center">
                    <i class="fas fa-download mr-1"></i> Download
                </a>
                {% if telegram_url %}
                <a href="{{ telegram_url }}" class="px-4 py-2 rounded bg-zinc-900 border border-zinc-700 text-sm text-gray-100 hover:border-yellow-500 font-bold transition w-full sm:w-auto text-center">
                    <i class="fab fa-telegram mr-1"></i> Telegram
                </a>
                {% endif %}
            </div>
        </div>

        <div class="bg-black min-h-[260px] sm:min-h-[400px] flex justify-center items-center relative group">
            
            {% if "video" in item.mime_type or item.name.lower().endswith(('.mp4', '.mkv', '.webm', '.mov', '.avi')) %}
                <video id="publicPlayer" controls autoplay preload="auto" data-hls="{{ hls_url or '' }}" class="w-full max-h-[70vh] outline-none">
                    <source src="{{ stream_url }}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            
            {% elif "image" in item.mime_type or item.name.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')) %}
                <img src="{{ stream_url }}" alt="{{ item.name }}" class="max-w-full max-h-[70vh] object-contain">
            
            {% elif "audio" in item.mime_type or item.name.lower().endswith(('.mp3', '.wav', '.ogg', '.m4a')) %}
                <div class="text-center p-10">
                    <div class="w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center mx-auto mb-6 shadow-inner animate-pulse">
                        <i class="fas fa-music text-4xl text-red-500"></i>
                    </div>
                    <audio controls autoplay class="w-full max-w-md">
                        <source src="{{ stream_url }}" type="audio/mpeg">
                    </audio>
                </div>

            {% else %}
                <div class="text-center p-10">
                    <i class="fas fa-file-archive text-6xl text-gray-600 mb-4"></i>
                    <p class="text-gray-400 text-lg">Preview not available</p>
                    <p class="text-sm text-gray-500 mb-6">{{ item.formatted_size }}</p>
                    <a href="{{ download_url or stream_url }}" class="bg-red-600 hover:bg-red-500 text-white px-8 py-3 rounded-full font-bold text-lg transition shadow-red-glow">
                        Download File
                    </a>
                </div>
            {% endif %}
        </div>

        <div class="bg-zinc-950 p-4 border-t border-zinc-800 flex flex-col md:flex-row md:items-center gap-4">
            <div class="flex flex-wrap gap-2 w-full md:w-auto md:justify-end md:ml-auto">
                <select id="publicQuality" class="bg-zinc-900 border border-zinc-700 text-white text-xs rounded px-3 py-2 w-full sm:w-auto">
                    <option value="-1">Quality: Original</option>
                </select>
                <select id="publicSubtitle" class="bg-zinc-900 border border-zinc-700 text-white text-xs rounded px-3 py-2 w-full sm:w-auto">
                    <option value="-1">Subtitles: Off</option>
                </select>
                <select id="publicAudio" class="bg-zinc-900 border border-zinc-700 text-white text-xs rounded px-3 py-2 w-full sm:w-auto">
                    <option value="-1">Audio: Default</option>
                </select>
                <select id="publicSpeed" class="bg-zinc-900 border border-zinc-700 text-white text-xs rounded px-3 py-2 w-full sm:w-auto">
                    <option value="1">Speed: 1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                </select>
            </div>
        </div>

        <div class="bg-zinc-950 p-4 border-t border-zinc-800 text-sm text-gray-400 flex flex-col sm:flex-row sm:justify-between gap-2">
            <span>Size: <span class="text-white">{{ item.formatted_size }}</span></span>
            <span>Type: <span class="text-white uppercase">{{ item.mime_type.split('/')[1] if '/' in item.mime_type else 'FILE' }}</span></span>
        </div>
    </div>

</div>

<style>
    .viewer-gate {
        position: fixed;
        inset: 0;
        background: rgba(5, 6, 12, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 60;
        backdrop-filter: blur(10px);
    }

    .viewer-gate.hidden {
        display: none;
    }

    .viewer-card {
        width: min(420px, 90vw);
        background: rgba(12, 12, 12, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        padding: 24px;
        text-align: center;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
    }

    .viewer-title {
        font-size: 20px;
        font-weight: 700;
        color: #fff;
    }

    .viewer-sub {
        margin-top: 8px;
        font-size: 13px;
        color: #9aa4b2;
    }

    .viewer-input {
        margin-top: 16px;
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(10, 10, 10, 0.92);
        color: #fff;
        font-size: 14px;
    }

    .viewer-btn {
        width: 100%;
        justify-content: center;
        margin-top: 12px;
        padding: 10px 18px;
        border-radius: 999px;
        font-weight: 700;
        font-size: 13px;
        background: #e50914;
        color: #fff;
        border: none;
        box-shadow: 0 10px 30px rgba(229, 9, 20, 0.35);
        cursor: pointer;
    }

    .viewer-hint {
        margin-top: 10px;
        font-size: 12px;
        color: #9aa4b2;
    }

    @media (max-width: 480px) {
        .viewer-card { padding: 18px; }
        .viewer-title { font-size: 18px; }
        .viewer-sub { font-size: 12px; }
    }

</style>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
const publicApp = document.getElementById("publicApp");
const token = publicApp.dataset.token;
const viewerName = publicApp.dataset.username;

const viewerGate = document.getElementById("viewerGate");
const viewerInput = document.getElementById("viewerInput");
const viewerSubmit = document.getElementById("viewerSubmit");
const viewerHint = document.getElementById("viewerHint");

function openViewerGate() {
    if (!viewerGate) return;
    viewerGate.classList.remove("hidden");
    viewerInput?.focus();
}

async function resolveViewerName(rawName) {
    const res = await fetch(`/s/resolve_user?name=${encodeURIComponent(rawName)}`);
    const data = await res.json();
    if (data.exists) {
        viewerHint.textContent = `Matched: ${data.resolved}`;
    } else {
        viewerHint.textContent = "New viewer saved as guest.";
    }
    return data.resolved || rawName;
}

if (viewerName) {
    viewerGate?.classList.add("hidden");
} else {
    openViewerGate();
}

viewerSubmit?.addEventListener("click", async () => {
    const raw = (viewerInput?.value || "").trim();
    if (!raw) return;
    const resolved = await resolveViewerName(raw);
    window.location.href = `/s/${token}?U=${encodeURIComponent(resolved)}&t={{ link_token }}`;
});

const itemId = publicApp.dataset.itemId;
const player = document.getElementById("publicPlayer");
const qualitySelect = document.getElementById("publicQuality");
const subtitleSelect = document.getElementById("publicSubtitle");
const audioSelect = document.getElementById("publicAudio");
const speedSelect = document.getElementById("publicSpeed");

function setSelectState(select, enabled) {
    if (!select) return;
    select.disabled = !enabled;
    select.classList.toggle("opacity-50", !enabled);
}

function resetPublicTracks() {
    if (qualitySelect) qualitySelect.innerHTML = `<option value="-1">Quality: Original</option>`;
    if (subtitleSelect) subtitleSelect.innerHTML = `<option value="-1">Subtitles: Off</option>`;
    if (audioSelect) audioSelect.innerHTML = `<option value="-1">Audio: Default</option>`;
    setSelectState(qualitySelect, false);
    setSelectState(subtitleSelect, false);
    setSelectState(audioSelect, false);
}

function setupPublicHlsControls(hls) {
    resetPublicTracks();
    if (qualitySelect && hls.levels && hls.levels.length) {
        qualitySelect.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "-1";
        autoOpt.textContent = "Quality: Auto";
        qualitySelect.appendChild(autoOpt);
        hls.levels.forEach((lvl, idx) => {
            const opt = document.createElement("option");
            const label = lvl.height ? `${lvl.height}p` : `${Math.round((lvl.bitrate || 0) / 1000)} kbps`;
            opt.value = String(idx);
            opt.textContent = `Quality: ${label}`;
            qualitySelect.appendChild(opt);
        });
        qualitySelect.onchange = () => {
            const v = parseInt(qualitySelect.value, 10);
            hls.currentLevel = Number.isNaN(v) ? -1 : v;
        };
        const current = typeof hls.currentLevel === "number" ? hls.currentLevel : -1;
        qualitySelect.value = String(current);
        setSelectState(qualitySelect, true);
    }
    if (audioSelect && hls.audioTracks && hls.audioTracks.length) {
        audioSelect.innerHTML = "";
        const defOpt = document.createElement("option");
        defOpt.value = "-1";
        defOpt.textContent = "Audio: Default";
        audioSelect.appendChild(defOpt);
        hls.audioTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Audio: ${track.name || track.lang || `Track ${idx + 1}`}`;
            audioSelect.appendChild(opt);
        });
        audioSelect.onchange = () => {
            const v = parseInt(audioSelect.value, 10);
            hls.audioTrack = v < 0 || Number.isNaN(v) ? 0 : v;
        };
        const current = typeof hls.audioTrack === "number" ? hls.audioTrack : 0;
        audioSelect.value = String(current);
        setSelectState(audioSelect, true);
    }
    if (subtitleSelect && hls.subtitleTracks && hls.subtitleTracks.length) {
        subtitleSelect.innerHTML = "";
        const off = document.createElement("option");
        off.value = "-1";
        off.textContent = "Subtitles: Off";
        subtitleSelect.appendChild(off);
        hls.subtitleTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Subtitles: ${track.name || track.lang || `Track ${idx + 1}`}`;
            subtitleSelect.appendChild(opt);
        });
        subtitleSelect.onchange = () => {
            const v = parseInt(subtitleSelect.value, 10);
            hls.subtitleTrack = Number.isNaN(v) ? -1 : v;
        };
        const current = typeof hls.subtitleTrack === "number" ? hls.subtitleTrack : -1;
        subtitleSelect.value = String(current);
        setSelectState(subtitleSelect, true);
    }
}

function setupNativeTracks(playerEl) {
    if (!playerEl) return;
    if (qualitySelect) {
        qualitySelect.innerHTML = `<option value="-1">Quality: Auto</option>`;
        setSelectState(qualitySelect, false);
    }
    if (audioSelect) {
        const tracks = playerEl.audioTracks ? Array.from(playerEl.audioTracks) : [];
        if (tracks.length) {
            audioSelect.innerHTML = "";
            const defOpt = document.createElement("option");
            defOpt.value = "-1";
            defOpt.textContent = "Audio: Default";
            audioSelect.appendChild(defOpt);
            tracks.forEach((t, idx) => {
                const opt = document.createElement("option");
                opt.value = String(idx);
                opt.textContent = `Audio: ${t.label || t.language || `Track ${idx + 1}`}`;
                audioSelect.appendChild(opt);
            });
            audioSelect.onchange = () => {
                const v = parseInt(audioSelect.value, 10);
                const target = v < 0 || Number.isNaN(v) ? 0 : v;
                tracks.forEach((t, idx) => { t.enabled = idx === target; });
            };
            const enabledIdx = tracks.findIndex(t => t.enabled);
            audioSelect.value = String(enabledIdx >= 0 ? enabledIdx : 0);
            setSelectState(audioSelect, true);
        } else {
            audioSelect.innerHTML = `<option value="-1">Audio: Default</option>`;
            setSelectState(audioSelect, false);
        }
    }
    if (subtitleSelect) {
        const tracks = playerEl.textTracks ? Array.from(playerEl.textTracks).filter(t => t.kind === "subtitles" || t.kind === "captions") : [];
        if (tracks.length) {
            subtitleSelect.innerHTML = "";
            const off = document.createElement("option");
            off.value = "-1";
            off.textContent = "Subtitles: Off";
            subtitleSelect.appendChild(off);
            tracks.forEach((t, idx) => {
                const opt = document.createElement("option");
                opt.value = String(idx);
                opt.textContent = `Subtitles: ${t.label || t.language || `Track ${idx + 1}`}`;
                subtitleSelect.appendChild(opt);
            });
            subtitleSelect.onchange = () => {
                const v = parseInt(subtitleSelect.value, 10);
                if (Number.isNaN(v) || v < 0) {
                    tracks.forEach(t => { t.mode = "disabled"; });
                } else {
                    tracks.forEach((t, idx) => { t.mode = idx === v ? "showing" : "disabled"; });
                }
            };
            setSelectState(subtitleSelect, true);
        } else {
            subtitleSelect.innerHTML = `<option value="-1">Subtitles: Off</option>`;
            setSelectState(subtitleSelect, false);
        }
    }
}

if (player) {
    const hlsUrl = player.dataset.hls;
    if (hlsUrl) {
        fetch(`/s/hls/prepare/${itemId}`, { method: "POST" });
        if (window.Hls && Hls.isSupported()) {
            const hls = new Hls({
                maxBufferLength: 90,
                maxMaxBufferLength: 180,
                maxBufferSize: 80 * 1000 * 1000,
                backBufferLength: 60,
                maxBufferHole: 0.2,
                startFragPrefetch: true
            });
            const refreshTracks = () => setupPublicHlsControls(hls);
            hls.on(Hls.Events.MANIFEST_PARSED, refreshTracks);
            hls.on(Hls.Events.LEVELS_UPDATED, refreshTracks);
            hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, refreshTracks);
            hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, refreshTracks);
            hls.on(Hls.Events.LEVEL_SWITCHED, () => {
                if (qualitySelect) qualitySelect.value = String(hls.currentLevel);
            });
            hls.loadSource(hlsUrl);
            hls.attachMedia(player);
        } else if (player.canPlayType("application/vnd.apple.mpegurl")) {
            player.src = hlsUrl;
            player.addEventListener("loadedmetadata", () => setupNativeTracks(player));
        }
    } else {
        resetPublicTracks();
    }
    speedSelect?.addEventListener("change", (e) => {
        player.playbackRate = parseFloat(e.target.value);
    });

    let lastSent = 0;
    player.addEventListener("timeupdate", () => {
        if (!viewerName) return;
        if (player.currentTime - lastSent > 10) {
            lastSent = player.currentTime;
            sendProgress();
        }
    });
    player.addEventListener("pause", sendProgress);
    player.addEventListener("ended", sendProgress);

    async function sendProgress() {
        if (!viewerName) return;
        await fetch("/s/progress", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                token,
                item_id: itemId,
                user_name: viewerName,
                position: player.currentTime || 0,
                duration: player.duration || 0
            })
        });
    }

    async function fetchResume() {
        if (!viewerName) return;
        const res = await fetch(`/s/progress?token=${encodeURIComponent(token)}&item_id=${encodeURIComponent(itemId)}&user=${encodeURIComponent(viewerName)}`);
        const data = await res.json();
        if (data.position && data.position > 5) {
            const shouldResume = confirm("Continue from last time?");
            if (shouldResume) player.currentTime = data.position;
        }
    }
    fetchResume();

    // Double tap skip (mobile-style)
    let lastTap = 0;
    player.addEventListener("pointerup", (e) => {
        if (e.pointerType !== "touch") return;
        const now = Date.now();
        if (now - lastTap < 300) {
            const rect = player.getBoundingClientRect();
            const isLeft = e.clientX < rect.left + rect.width / 2;
            player.currentTime = Math.max(0, player.currentTime + (isLeft ? -10 : 10));
        }
        lastTap = now;
    });

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            player.requestFullscreen?.();
        } else {
            document.exitFullscreen?.();
        }
    }

    document.addEventListener("keydown", (e) => {
        if (e.code === "Space") { e.preventDefault(); player.paused ? player.play() : player.pause(); }
        if (e.code === "ArrowRight") player.currentTime += 10;
        if (e.code === "ArrowLeft") player.currentTime -= 10;
        if (e.key && e.key.toLowerCase() === "f") toggleFullscreen();
    });
}
</script>

{% endblock %}
