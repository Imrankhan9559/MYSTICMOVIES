{% extends "base.html" %}
{% block content %}
<div class="container mx-auto mt-6 flex flex-col items-center">
    
    <div class="w-full max-w-6xl flex justify-between items-center mb-4 bg-gray-800 p-4 rounded-t-lg border-b border-red-600">
        <h2 class="text-xl font-bold text-white truncate max-w-md">{{ item.name }}</h2>
        <a href="/dashboard?folder_id={{ item.parent_id if item.parent_id else '' }}" class="text-gray-400 hover:text-white transition">
            <i class="fas fa-times text-xl"></i> Close
        </a>
    </div>

    <div class="w-full max-w-6xl bg-black rounded-b-lg shadow-2xl overflow-hidden border border-gray-700 flex justify-center items-center min-h-[500px] relative">
        
        {% if "video" in item.mime_type or item.name.lower().endswith(('.mp4', '.mkv', '.webm', '.mov', '.avi')) %}
            <video id="authPlayer" controls autoplay preload="auto" data-hls="{{ hls_url or '' }}" class="w-full max-h-[80vh] outline-none">
                <source src="{{ stream_url }}" type="{{ item.mime_type or 'video/mp4' }}">
                Your browser does not support the video tag.
            </video>
            <div class="flex flex-wrap gap-2 mt-4">
                <select id="authQuality" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Quality: Original</option>
                </select>
                <select id="authSubtitle" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Subtitles: Off</option>
                </select>
                <select id="authAudio" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Audio: Default</option>
                </select>
                <select id="authSpeed" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="1">Speed: 1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                </select>
            </div>

        {% elif "image" in item.mime_type or item.name.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')) %}
            <img src="{{ stream_url }}" alt="{{ item.name }}" class="max-w-full max-h-[80vh] object-contain">

        {% elif "audio" in item.mime_type or item.name.lower().endswith(('.mp3', '.wav', '.ogg', '.m4a')) %}
            <div class="p-10 text-center">
                <i class="fas fa-music text-6xl text-red-500 mb-6 animate-pulse"></i>
                <audio controls autoplay class="w-96">
                    <source src="{{ stream_url }}" type="audio/mpeg">
                </audio>
            </div>

        {% elif "text" in item.mime_type or "json" in item.mime_type or "xml" in item.mime_type or item.name.lower().endswith(('.txt', '.py', '.js', '.html', '.css', '.json', '.md')) %}
            <div class="w-full h-[600px] bg-gray-900 text-gray-200 p-0 overflow-hidden font-mono text-sm">
                <iframe src="{{ stream_url }}" class="w-full h-full border-none bg-white"></iframe>
            </div>

        {% else %}
            <div class="text-center p-10">
                <i class="fas fa-file-invoice text-6xl text-gray-500 mb-4"></i>
                <p class="text-xl text-gray-400">Preview not available for this type.</p>
                <p class="text-sm text-gray-600 mb-4">Detected Type: {{ item.mime_type }}</p>
                <a href="{{ stream_url }}" class="mt-4 inline-block bg-red-600 text-white px-6 py-2 rounded hover:bg-red-500">
                    Download File
                </a>
            </div>
        {% endif %}
    </div>

    <div class="w-full max-w-6xl mt-4 bg-gray-800 p-6 rounded-lg text-gray-400 text-sm flex justify-between items-center">
        <div>
            <span class="mr-4"><i class="fas fa-hdd mr-2"></i> Size: {{ item.formatted_size }}</span>
            <span><i class="fas fa-clock mr-2"></i> Uploaded: {{ item.created_at.strftime('%Y-%m-%d %H:%M') }}</span>
        </div>
        <a href="{{ stream_url }}" download="{{ item.name }}" class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded font-bold transition">
            <i class="fas fa-download mr-1"></i> Download
        </a>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
const authPlayer = document.getElementById("authPlayer");
const resumeAt = {{ resume_at or 0 }};
const authQuality = document.getElementById("authQuality");
const authSubtitle = document.getElementById("authSubtitle");
const authAudio = document.getElementById("authAudio");
const authSpeed = document.getElementById("authSpeed");
let authHls = null;

function resetAuthTracks() {
    if (authQuality) authQuality.innerHTML = `<option value="-1">Quality: Original</option>`;
    if (authSubtitle) authSubtitle.innerHTML = `<option value="-1">Subtitles: Off</option>`;
    if (authAudio) authAudio.innerHTML = `<option value="-1">Audio: Default</option>`;
}

function setupAuthHlsControls(hls) {
    resetAuthTracks();
    if (authQuality && hls.levels && hls.levels.length) {
        authQuality.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "-1";
        autoOpt.textContent = "Quality: Auto";
        authQuality.appendChild(autoOpt);
        hls.levels.forEach((lvl, idx) => {
            const opt = document.createElement("option");
            const label = lvl.height ? `${lvl.height}p` : `${Math.round((lvl.bitrate || 0) / 1000)} kbps`;
            opt.value = String(idx);
            opt.textContent = `Quality: ${label}`;
            authQuality.appendChild(opt);
        });
        authQuality.onchange = () => {
            hls.currentLevel = parseInt(authQuality.value, 10);
        };
    }
    if (authAudio && hls.audioTracks && hls.audioTracks.length) {
        authAudio.innerHTML = "";
        hls.audioTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Audio: ${track.name || track.lang || `Track ${idx + 1}`}`;
            authAudio.appendChild(opt);
        });
        authAudio.onchange = () => {
            hls.audioTrack = parseInt(authAudio.value, 10);
        };
    }
    if (authSubtitle && hls.subtitleTracks && hls.subtitleTracks.length) {
        authSubtitle.innerHTML = "";
        const off = document.createElement("option");
        off.value = "-1";
        off.textContent = "Subtitles: Off";
        authSubtitle.appendChild(off);
        hls.subtitleTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Subtitles: ${track.name || track.lang || `Track ${idx + 1}`}`;
            authSubtitle.appendChild(opt);
        });
        authSubtitle.onchange = () => {
            hls.subtitleTrack = parseInt(authSubtitle.value, 10);
        };
    }
}

function switchToAuthHls(hlsUrl) {
    const currentTime = authPlayer.currentTime || 0;
    const wasPlaying = !authPlayer.paused;
    if (window.Hls && Hls.isSupported()) {
        if (authHls) authHls.destroy();
        authHls = new Hls({
            maxBufferLength: 300,
            maxMaxBufferLength: 600,
            maxBufferSize: 120 * 1000 * 1000,
            backBufferLength: 60
        });
        authHls.startPosition = currentTime;
        authHls.on(Hls.Events.MANIFEST_PARSED, () => {
            setupAuthHlsControls(authHls);
            if (currentTime > 0) authPlayer.currentTime = currentTime;
            if (wasPlaying) authPlayer.play();
        });
        authHls.loadSource(hlsUrl);
        authHls.attachMedia(authPlayer);
    } else if (authPlayer.canPlayType("application/vnd.apple.mpegurl")) {
        authPlayer.src = hlsUrl;
        if (currentTime > 0) authPlayer.currentTime = currentTime;
        if (wasPlaying) authPlayer.play();
    }
}

async function warmAuthHls() {
    const hlsUrlBase = authPlayer.dataset.hls || `/static/hls/{{ item.id }}/index.m3u8`;
    const hlsFallback = hlsUrlBase.includes("/index.m3u8")
        ? hlsUrlBase.replace("/index.m3u8", "/master.m3u8")
        : hlsUrlBase.replace("/master.m3u8", "/index.m3u8");
    await fetch("/hls/prepare/{{ item.id }}", { method: "POST" });

    let ready = false;
    let chosen = hlsUrlBase;
    for (let i = 0; i < 20; i++) {
        try {
            const res = await fetch(chosen, { method: "HEAD" });
            if (res.ok) { ready = true; break; }
        } catch (e) {}
        await new Promise(r => setTimeout(r, 2000));
    }
    if (!ready && hlsFallback !== hlsUrlBase) {
        chosen = hlsFallback;
        for (let i = 0; i < 20; i++) {
            try {
                const res = await fetch(chosen, { method: "HEAD" });
                if (res.ok) { ready = true; break; }
            } catch (e) {}
            await new Promise(r => setTimeout(r, 2000));
        }
    }
    if (ready) switchToAuthHls(chosen);
}

if (authPlayer) {
    resetAuthTracks();
    authPlayer.src = "{{ stream_url }}";
    warmAuthHls();

    authSpeed?.addEventListener("change", (e) => {
        authPlayer.playbackRate = parseFloat(e.target.value);
    });

    if (resumeAt > 5) {
        const resume = confirm("Continue from last time?");
        if (resume) authPlayer.currentTime = resumeAt;
    }

    let lastSent = 0;
    authPlayer.addEventListener("timeupdate", () => {
        if (authPlayer.currentTime - lastSent > 10) {
            lastSent = authPlayer.currentTime;
            sendProgress();
        }
    });
    authPlayer.addEventListener("pause", sendProgress);
    authPlayer.addEventListener("ended", sendProgress);

    async function sendProgress() {
        await fetch("/progress", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                item_id: "{{ item.id }}",
                position: authPlayer.currentTime || 0,
                duration: authPlayer.duration || 0
            })
        });
    }

    // Double tap skip (mobile-style)
    let lastTap = 0;
    authPlayer.addEventListener("pointerup", (e) => {
        if (e.pointerType !== "touch") return;
        const now = Date.now();
        if (now - lastTap < 300) {
            const rect = authPlayer.getBoundingClientRect();
            const isLeft = e.clientX < rect.left + rect.width / 2;
            authPlayer.currentTime = Math.max(0, authPlayer.currentTime + (isLeft ? -10 : 10));
        }
        lastTap = now;
    });

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            authPlayer.requestFullscreen?.();
        } else {
            document.exitFullscreen?.();
        }
    }

    document.addEventListener("keydown", (e) => {
        if (e.code === "Space") { e.preventDefault(); authPlayer.paused ? authPlayer.play() : authPlayer.pause(); }
        if (e.code === "ArrowRight") authPlayer.currentTime += 10;
        if (e.code === "ArrowLeft") authPlayer.currentTime -= 10;
        if (e.key && e.key.toLowerCase() === "f") toggleFullscreen();
    });
}
</script>
{% endblock %}
