{% extends "base.html" %}
{% block content %}
<div class="container mx-auto mt-6 flex flex-col items-center">
    
    <div class="w-full max-w-6xl flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 mb-4 bg-gray-800 p-4 rounded-t-lg border-b border-red-600">
        <h2 class="text-xl font-bold text-white truncate max-w-md">{{ item.name }}</h2>
        <a href="/dashboard?folder_id={{ item.parent_id if item.parent_id else '' }}" class="text-gray-400 hover:text-white transition self-end sm:self-auto">
            <i class="fas fa-times text-xl"></i> Close
        </a>
    </div>

    <div class="w-full max-w-6xl bg-black rounded-b-lg shadow-2xl overflow-hidden border border-gray-700 flex flex-col items-stretch min-h-[280px] sm:min-h-[500px] relative">
        
        {% if "video" in item.mime_type or item.name.lower().endswith(('.mp4', '.mkv', '.webm', '.mov', '.avi')) %}
            <video id="authPlayer" controls autoplay preload="auto" data-hls="{{ hls_url or '' }}" class="w-full max-h-[80vh] outline-none">
                <source src="{{ stream_url }}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <div class="flex flex-wrap gap-2 mt-4 px-4 pb-4 w-full justify-center sm:justify-start">
                <select id="authQuality" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Quality: Original</option>
                </select>
                <select id="authSubtitle" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Subtitles: Off</option>
                </select>
                <select id="authAudio" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="-1">Audio: Default</option>
                </select>
                <select id="authSpeed" class="bg-gray-800 border border-gray-700 text-white text-xs rounded px-3 py-2">
                    <option value="1">Speed: 1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                </select>
            </div>

        {% elif "image" in item.mime_type or item.name.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')) %}
            <img src="{{ stream_url }}" alt="{{ item.name }}" class="max-w-full max-h-[80vh] object-contain">

        {% elif "audio" in item.mime_type or item.name.lower().endswith(('.mp3', '.wav', '.ogg', '.m4a')) %}
            <div class="p-10 text-center">
                <i class="fas fa-music text-6xl text-red-500 mb-6 animate-pulse"></i>
                <audio controls autoplay class="w-full max-w-md">
                    <source src="{{ stream_url }}" type="audio/mpeg">
                </audio>
            </div>

        {% elif "text" in item.mime_type or "json" in item.mime_type or "xml" in item.mime_type or item.name.lower().endswith(('.txt', '.py', '.js', '.html', '.css', '.json', '.md')) %}
            <div class="w-full h-[60vh] sm:h-[600px] bg-gray-900 text-gray-200 p-0 overflow-hidden font-mono text-sm">
                <iframe src="{{ stream_url }}" class="w-full h-full border-none bg-white"></iframe>
            </div>

        {% else %}
            <div class="text-center p-10">
                <i class="fas fa-file-invoice text-6xl text-gray-500 mb-4"></i>
                <p class="text-xl text-gray-400">Preview not available for this type.</p>
                <p class="text-sm text-gray-600 mb-4">Detected Type: {{ item.mime_type }}</p>
                <a href="{{ stream_url }}" class="mt-4 inline-block bg-red-600 text-white px-6 py-2 rounded hover:bg-red-500">
                    Download File
                </a>
            </div>
        {% endif %}
    </div>

    <div class="w-full max-w-6xl mt-4 bg-gray-800 p-6 rounded-lg text-gray-400 text-sm flex flex-col sm:flex-row sm:items-center gap-3">
        <div class="flex flex-wrap gap-3">
            <span class="mr-4"><i class="fas fa-hdd mr-2"></i> Size: {{ item.formatted_size }}</span>
            <span><i class="fas fa-clock mr-2"></i> Uploaded: {{ item.created_at.strftime('%Y-%m-%d %H:%M') }}</span>
        </div>
        <a href="{{ stream_url }}" download="{{ item.name }}" class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded font-bold transition">
            <i class="fas fa-download mr-1"></i> Download
        </a>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
const authPlayer = document.getElementById("authPlayer");
const resumeAt = {{ resume_at or 0 }};
const authQuality = document.getElementById("authQuality");
const authSubtitle = document.getElementById("authSubtitle");
const authAudio = document.getElementById("authAudio");
const authSpeed = document.getElementById("authSpeed");

function setSelectState(select, enabled) {
    if (!select) return;
    select.disabled = !enabled;
    select.classList.toggle("opacity-50", !enabled);
}

function resetAuthTracks() {
    if (authQuality) authQuality.innerHTML = `<option value="-1">Quality: Original</option>`;
    if (authSubtitle) authSubtitle.innerHTML = `<option value="-1">Subtitles: Off</option>`;
    if (authAudio) authAudio.innerHTML = `<option value="-1">Audio: Default</option>`;
    setSelectState(authQuality, false);
    setSelectState(authSubtitle, false);
    setSelectState(authAudio, false);
}

function setupAuthHlsControls(hls) {
    resetAuthTracks();
    if (authQuality && hls.levels && hls.levels.length) {
        authQuality.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "-1";
        autoOpt.textContent = "Quality: Auto";
        authQuality.appendChild(autoOpt);
        hls.levels.forEach((lvl, idx) => {
            const opt = document.createElement("option");
            const label = lvl.height ? `${lvl.height}p` : `${Math.round((lvl.bitrate || 0) / 1000)} kbps`;
            opt.value = String(idx);
            opt.textContent = `Quality: ${label}`;
            authQuality.appendChild(opt);
        });
        authQuality.onchange = () => {
            const v = parseInt(authQuality.value, 10);
            hls.currentLevel = Number.isNaN(v) ? -1 : v;
        };
        const current = typeof hls.currentLevel === "number" ? hls.currentLevel : -1;
        authQuality.value = String(current);
        setSelectState(authQuality, true);
    }
    if (authAudio && hls.audioTracks && hls.audioTracks.length) {
        authAudio.innerHTML = "";
        const defOpt = document.createElement("option");
        defOpt.value = "-1";
        defOpt.textContent = "Audio: Default";
        authAudio.appendChild(defOpt);
        hls.audioTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Audio: ${track.name || track.lang || `Track ${idx + 1}`}`;
            authAudio.appendChild(opt);
        });
        authAudio.onchange = () => {
            const v = parseInt(authAudio.value, 10);
            hls.audioTrack = v < 0 || Number.isNaN(v) ? 0 : v;
        };
        const current = typeof hls.audioTrack === "number" ? hls.audioTrack : 0;
        authAudio.value = String(current);
        setSelectState(authAudio, true);
    }
    if (authSubtitle && hls.subtitleTracks && hls.subtitleTracks.length) {
        authSubtitle.innerHTML = "";
        const off = document.createElement("option");
        off.value = "-1";
        off.textContent = "Subtitles: Off";
        authSubtitle.appendChild(off);
        hls.subtitleTracks.forEach((track, idx) => {
            const opt = document.createElement("option");
            opt.value = String(idx);
            opt.textContent = `Subtitles: ${track.name || track.lang || `Track ${idx + 1}`}`;
            authSubtitle.appendChild(opt);
        });
        authSubtitle.onchange = () => {
            const v = parseInt(authSubtitle.value, 10);
            hls.subtitleTrack = Number.isNaN(v) ? -1 : v;
        };
        const current = typeof hls.subtitleTrack === "number" ? hls.subtitleTrack : -1;
        authSubtitle.value = String(current);
        setSelectState(authSubtitle, true);
    }
}

function setupNativeTracks(playerEl) {
    if (!playerEl) return;
    if (authQuality) {
        authQuality.innerHTML = `<option value="-1">Quality: Auto</option>`;
        setSelectState(authQuality, false);
    }
    if (authAudio) {
        const tracks = playerEl.audioTracks ? Array.from(playerEl.audioTracks) : [];
        if (tracks.length) {
            authAudio.innerHTML = "";
            const defOpt = document.createElement("option");
            defOpt.value = "-1";
            defOpt.textContent = "Audio: Default";
            authAudio.appendChild(defOpt);
            tracks.forEach((t, idx) => {
                const opt = document.createElement("option");
                opt.value = String(idx);
                opt.textContent = `Audio: ${t.label || t.language || `Track ${idx + 1}`}`;
                authAudio.appendChild(opt);
            });
            authAudio.onchange = () => {
                const v = parseInt(authAudio.value, 10);
                const target = v < 0 || Number.isNaN(v) ? 0 : v;
                tracks.forEach((t, idx) => { t.enabled = idx === target; });
            };
            const enabledIdx = tracks.findIndex(t => t.enabled);
            authAudio.value = String(enabledIdx >= 0 ? enabledIdx : 0);
            setSelectState(authAudio, true);
        } else {
            authAudio.innerHTML = `<option value="-1">Audio: Default</option>`;
            setSelectState(authAudio, false);
        }
    }
    if (authSubtitle) {
        const tracks = playerEl.textTracks ? Array.from(playerEl.textTracks).filter(t => t.kind === "subtitles" || t.kind === "captions") : [];
        if (tracks.length) {
            authSubtitle.innerHTML = "";
            const off = document.createElement("option");
            off.value = "-1";
            off.textContent = "Subtitles: Off";
            authSubtitle.appendChild(off);
            tracks.forEach((t, idx) => {
                const opt = document.createElement("option");
                opt.value = String(idx);
                opt.textContent = `Subtitles: ${t.label || t.language || `Track ${idx + 1}`}`;
                authSubtitle.appendChild(opt);
            });
            authSubtitle.onchange = () => {
                const v = parseInt(authSubtitle.value, 10);
                if (Number.isNaN(v) || v < 0) {
                    tracks.forEach(t => { t.mode = "disabled"; });
                } else {
                    tracks.forEach((t, idx) => { t.mode = idx === v ? "showing" : "disabled"; });
                }
            };
            setSelectState(authSubtitle, true);
        } else {
            authSubtitle.innerHTML = `<option value="-1">Subtitles: Off</option>`;
            setSelectState(authSubtitle, false);
        }
    }
}

if (authPlayer) {
    const hlsUrl = authPlayer.dataset.hls;
    if (hlsUrl) {
        fetch("/hls/prepare/{{ item.id }}", { method: "POST" });
        if (window.Hls && Hls.isSupported()) {
            const hls = new Hls({
                maxBufferLength: 90,
                maxMaxBufferLength: 180,
                maxBufferSize: 80 * 1000 * 1000,
                backBufferLength: 60,
                maxBufferHole: 0.2,
                startFragPrefetch: true
            });
            const refreshTracks = () => setupAuthHlsControls(hls);
            hls.on(Hls.Events.MANIFEST_PARSED, refreshTracks);
            hls.on(Hls.Events.LEVELS_UPDATED, refreshTracks);
            hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, refreshTracks);
            hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, refreshTracks);
            hls.on(Hls.Events.LEVEL_SWITCHED, () => {
                if (authQuality) authQuality.value = String(hls.currentLevel);
            });
            hls.loadSource(hlsUrl);
            hls.attachMedia(authPlayer);
        } else if (authPlayer.canPlayType("application/vnd.apple.mpegurl")) {
            authPlayer.src = hlsUrl;
            authPlayer.addEventListener("loadedmetadata", () => setupNativeTracks(authPlayer));
        }
    } else {
        resetAuthTracks();
    }

    authSpeed?.addEventListener("change", (e) => {
        authPlayer.playbackRate = parseFloat(e.target.value);
    });

    if (resumeAt > 5) {
        const resume = confirm("Continue from last time?");
        if (resume) authPlayer.currentTime = resumeAt;
    }

    let lastSent = 0;
    authPlayer.addEventListener("timeupdate", () => {
        if (authPlayer.currentTime - lastSent > 10) {
            lastSent = authPlayer.currentTime;
            sendProgress();
        }
    });
    authPlayer.addEventListener("pause", sendProgress);
    authPlayer.addEventListener("ended", sendProgress);

    async function sendProgress() {
        await fetch("/progress", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                item_id: "{{ item.id }}",
                position: authPlayer.currentTime || 0,
                duration: authPlayer.duration || 0
            })
        });
    }

    // Double tap skip (mobile-style)
    let lastTap = 0;
    authPlayer.addEventListener("pointerup", (e) => {
        if (e.pointerType !== "touch") return;
        const now = Date.now();
        if (now - lastTap < 300) {
            const rect = authPlayer.getBoundingClientRect();
            const isLeft = e.clientX < rect.left + rect.width / 2;
            authPlayer.currentTime = Math.max(0, authPlayer.currentTime + (isLeft ? -10 : 10));
        }
        lastTap = now;
    });

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            authPlayer.requestFullscreen?.();
        } else {
            document.exitFullscreen?.();
        }
    }

    document.addEventListener("keydown", (e) => {
        if (e.code === "Space") { e.preventDefault(); authPlayer.paused ? authPlayer.play() : authPlayer.pause(); }
        if (e.code === "ArrowRight") authPlayer.currentTime += 10;
        if (e.code === "ArrowLeft") authPlayer.currentTime -= 10;
        if (e.key && e.key.toLowerCase() === "f") toggleFullscreen();
    });
}
</script>
{% endblock %}
